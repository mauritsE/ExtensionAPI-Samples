# IMicroflowExpressionService.TryGetComputedType method

Retrieve the type of the [`IMicroflowExpression`](../../Mendix.StudioPro.ExtensionsAPI.Model.MicroflowExpressions/IMicroflowExpression.md), if it has been computed.

```csharp
public bool TryGetComputedType(IModel model, IMicroflowExpression microflowExpression, 
    out DataType? dataType)
```

| parameter | description |
| --- | --- |
| model | Reference to the current app. |
| microflowExpression | Microflow expression which type should be determined. It must be a property of an elements that is added to the app model. |
| dataType | Type of *microflowExpression* represented by a [`DataType`](../../Mendix.StudioPro.ExtensionsAPI.Model.DataTypes/DataType.md), or `null` if it hasn't been computed. |

## Return Value

Returns `true` if data type of the expression is known and `false` otherwise.

## Remarks

Note, that `false` result can be intermittent and executing `TryGetComputedType` again at a later point in time might succeed.

## Examples

To read the type of an existing expression:

```csharp
if (!microflowExpressionOperator.TryGetComputedType(model, modelElement.Property, out var dataType))
    throw new InvalidOperationException();
switch (dataType)
{
    case IStringType:
        return "string";
    case IObjectType objectType:
        return $"object of type {objectType.Entity}";
    // etc
}
```

This method will never return `true` when called with an expression that is not part of a model:

```csharp
if (microflowExpressionOperator.TryGetComputedType(model, microflowExpressionOperator.CreateFromString(newExpressionValue), out var dataType))
{
    // this code will never execute
}
```

Nor will it work with an expression that has been just assigned to the app model:

```csharp
modelElement.Property = microflowExpressionOperator.CreateFromString(newExpressionValue);;
if (microflowExpressionOperator.TryGetComputedType(model, modelElement.Property, out var dataType))
{
    // this code will never execute
}
```

If you need to read the type after setting it, use the following approach:

```csharp
using var tx = model.StartTransaction("Change argument");
modelElement.Property = microflowExpressionOperator.CreateFromString(newExpressionValue);;
tx.Commit(); // this line is required

if (microflowExpressionOperator.TryGetComputedType(model, modelElement.Property, out var dataType))
{
    // use dataType
}
});
```

## See Also

* interface [IModel](../../Mendix.StudioPro.ExtensionsAPI.Model/IModel.md)
* interface [IMicroflowExpression](../../Mendix.StudioPro.ExtensionsAPI.Model.MicroflowExpressions/IMicroflowExpression.md)
* class [DataType](../../Mendix.StudioPro.ExtensionsAPI.Model.DataTypes/DataType.md)
* interface [IMicroflowExpressionService](../IMicroflowExpressionService.md)
* namespace [Mendix.StudioPro.ExtensionsAPI.Services](../../Mendix.StudioPro.ExtensionsAPI.md)

<!-- DO NOT EDIT: generated by xmldocmd for Mendix.StudioPro.ExtensionsAPI.dll -->
